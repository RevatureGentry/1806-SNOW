{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/utils/typecheck.js","webpack:///./src/js/lexer/MusicLexer.utils.js","webpack:///./src/js/player/Player.js","webpack:///./src/js/translator/MusicTranslator.utils.js","webpack:///./src/js/translator/MusicTranslator.js","webpack:///./src/js/lexer/TokenConverter.js","webpack:///./src/js/lexer/tokens.js","webpack:///./src/js/lexer/MusicLexer.js","webpack:///./src/js/generator/MusicGenerator.utils.js","webpack:///./src/js/generator/MusicGenerator.js","webpack:///./src/js/testing.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","typecheckString","input","Error","typecheckNumber","typecheckBool","preprocess","trimmed","trim","split","verifyToken","token","test","verifyUnit","unit","types","Player","_classCallCheck","this","_instruments","notes","_clearOldMusic","length","push","Tone","Synth","oscillator","type","harmonicity","modulationType","envelope","attackCurve","attack","decay","sustain","release","portamento","toMaster","overall_time","notes_array","dur_array","noteIndex","Transport","schedule","_scheduleNote","cancel","note","duration","instrument","time","triggerAttackRelease","start","pause","stop","translate","voice_array","units_per_minute","voice_index","duration_count","result","durations","errors","convertCountToDuration","minute_fraction","Math","floor","utils","MusicTranslator","_unit","_units_per_minute","_translation","_errors","unit_note","upm","error_message","voices_array","_clearOldTranslation","_doTranslate","getTranslation","initial_translation","getBaseUnit","getUnitsPerMinute","_addError","errors_array","concat","TokenToNoteConverter","_note_table","Map","_attr_table","tokenPosition","_getNote","NEW_VOICE","MusicLexer","_num_voices","_voices","_token_stream","_token_index","_unit_note","index","music","_doLexing","getAllVoices","_preprocessMusic","_process","_hasMoreMusicTokens","_nextMusicToken","curr_token_index","Tokens","_addNewVoice","_addOrRejectToken","_tokenIsInLanguage","_addNote","_convertTokenToNote","token_position","convert","getNumVoices","token_index","extractHeader","header","extracted","header_lines","title","author","modifiers","parseInt","beat","MusicGenerator","lexer","translator","_lexer","_translator","_author","_title","_beat","hasErrors","hasLexerErrors","hasTranslatorErrors","getErrors","getErrorSummary","music_file_string","_clearOldGeneratedMusic","_setHeaderValues","_extractHeaderValues","_lex","_extractScoreValues","_translate","getGeneratedMusic","setUnitsPerMinute","includes","score","lex","window","onload","event","console","log","generator","generate","player","playBtn","document","getElementById","stopBtn","addEventListener","play","disabled"],"mappings":"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","file":"test.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","export function typecheckString(input) {\n    if(typeof(input) !== 'string') {\n        throw new Error(\"input is not a string\");\n    }\n}\n\nexport function typecheckNumber(input) {\n    if(typeof(input) !== 'number') {\n        throw new Error(\"input is not a number\");\n    }\n}\n\nexport function typecheckBool(input) {\n    if(typeof(input) !== 'boolean') {\n        throw new Error(\"input is not a boolean\");\n    }\n}","\n\n\nexport function preprocess(input) {\n    typecheckString(input);\n\n    let trimmed = input.trim();\n    if(trimmed === \"\") {\n        return [];\n    } else {\n        return trimmed.split(/[\\s]+/);\n    }\n}\n\nexport function verifyToken(token) {\n    typecheckString(token);\n\n    // See regular expression documentation for JavaScript.\n    let noteFormat = /^([A-G][1-9]?|~|!)$/;\n    return noteFormat.test(token);\n}\n\nexport function typecheckString(input) {\n    if(typeof(input) !== 'string') {\n        throw new Error(\"input is not a string\");\n    }\n}\n\nexport function typecheckNumber(input) {\n    if(typeof(input) !== 'number') {\n        throw new Error(\"input is not a number\");\n    }\n}\n\nexport function verifyUnit(unit) {\n    typecheckString(unit);\n\n    //see regex documentation for JavaScript.\n    let unitFormat = /^(([1248])|16)$/;\n    return unitFormat.test(unit);\n\n}","\nimport * as types from \"../utils/typecheck\";\n\n// This class is reponsible for taking a lexed and translated\n// *.music file and playing it in the browser. Therefore it will utilize Tone.js\n// To use this class, schedule notes. Then Play, Pause, and/or Stop them.\n\nclass Player {\n    constructor() {\n        this._instruments = [];\n    }\n\n    /*\n        example notes:\n        [  // array of voices.\n            [   // each voice is an array of notes and durations to play them.\n                [\"A4\", \"B4\"],\n                [1, 2], // The intention is to play notes in sequence.\n            ],\n            [\n                [\"C4\", \"D4\"],\n                [3, 5],\n\n                // Note that voices do not play at identical times. \"D4\" will start\n                // when \"B4\" ends. That is how the scheduling works.\n            ]\n        ]\n    */\n    schedule(notes) {\n        this._clearOldMusic();\n\n        for(let i = 0; i < notes.length; i++) {\n            if(notes[i][0].length !== notes[i][1].length) {\n                throw new Error(\"number of notes does not equal number of durations\");\n            }\n            // add an instrument for each voice.\n            this._instruments.push(new Tone.Synth({\n                \"oscillator\" : {\n                    \"type\" : \"amtriangle\",\n                    \"harmonicity\" : 0.5,\n                    \"modulationType\" : \"sine\"\n                },\n                \"envelope\" : {\n                    \"attackCurve\" : 'exponential',\n                    \"attack\" : 0.05,\n                    \"decay\" : 0.2,\n                    \"sustain\" : 0.2,\n                    \"release\" : 0.5,\n                },\n                \"portamento\" : 0.05\n            }).toMaster());\n\n            //for each note-duration pair, schedule the note with correct duration.\n            // ALSO schedule rests by updating the overall time.\n            let overall_time = 0;\n            let notes_array = notes[i][0];\n            let dur_array = notes[i][1];\n            for(let noteIndex = 0; noteIndex < notes_array.length; noteIndex++) {\n                // If note is not a rest, schedule it.\n                if(notes_array[noteIndex]) {\n                    Tone.Transport.schedule(\n                        this._scheduleNote(notes_array[noteIndex], dur_array[noteIndex]),\n                        overall_time\n                    );\n                }\n\n                // Increment the overall_time for the scheduling of the next note.\n                overall_time += dur_array[noteIndex];\n            }\n        }\n    }\n\n    _clearOldMusic() {\n        Tone.Transport.cancel();\n    }\n\n    _scheduleNote(note, duration) {\n        types.typecheckString(note);\n        types.typecheckNumber(duration);\n\n        let instrument = this._instruments[this._instruments.length - 1];\n        return function playNote(time) {\n            instrument.triggerAttackRelease(note, duration, time);\n        }\n    }\n\n    play() {\n        Tone.Transport.start('+0.1');\n\n        /*\n        let instrument = this._instrument;\n        let instrument_2 = this._instrument_2;\n        return function doPlay(time) {\n            instrument_2.triggerAttackRelease(\"G4\", \"3\", time);\n            instrument.triggerAttackRelease(\"C4\", \"3\", time);\n        }*/\n    }\n\n    pause() {\n        Tone.Transport.pause();\n    }\n\n    stop() {\n        Tone.Transport.stop();\n    }\n}\n\nexport default Player;\n","import * as types from \"../utils/typecheck\";\n\nexport function verifyUnit(unit) {\n    types.typecheckNumber(unit);\n\n    return  unit === 1 ||\n            unit === 2 ||\n            unit === 4 ||\n            unit === 8 ||\n            unit === 16;\n}\n\n/*\n    Returns an array of the form\n    [\n        notes_array,\n        duration_array,\n        errors_array    [OPTIONAL]\n    ]\n*/\nexport function translate(voice_array, unit, units_per_minute) {\n    types.typecheckNumber(unit);\n    types.typecheckNumber(units_per_minute);\n\n    let voice_index = 0;\n    let duration_count = 0;\n\n    const result = [];\n    const notes = [];\n    const durations = [];\n    const errors = [];\n\n    while(voice_index < voice_array.length) {\n        if(voice_array[voice_index] === \"~\") {\n            if(duration_count === 0) {\n                errors.push([voice_array[voice_index], voice_index]);\n            } else {\n                duration_count += 1;\n            }\n        }\n        else {\n            // Then the token is a note or rest.\n            const note = voice_array[voice_index] === \"!\" ? null : voice_array[voice_index];\n\n            // Add the note.\n            notes.push(note);\n\n            // Add the duration of the previous note.\n            if(duration_count > 0) {\n                durations.push(convertCountToDuration(duration_count, unit, units_per_minute));\n            }\n\n            // Reset the duration.\n            duration_count = 1;\n        }\n              \n        // Increment to look at next voice token.\n        voice_index++;\n    };\n\n    // Add the last duration, since it would not have added during the loop.\n    durations.push(convertCountToDuration(duration_count, unit, units_per_minute));\n\n    // TODO: Return correct value by processing the voice_array.\n\n    result.push(notes);\n    result.push(durations);\n    result.push(errors);\n    return result;\n}\n\nexport function convertCountToDuration(duration_count, unit, units_per_minute) {\n    types.typecheckNumber(duration_count);\n    types.typecheckNumber(unit);\n    types.typecheckNumber(units_per_minute);\n\n    const minute_fraction = duration_count / units_per_minute;\n    const duration_in_seconds = Math.floor(minute_fraction * 60 * 1000) / 1000;\n\n    return duration_in_seconds;\n}","\nimport * as types from \"../utils/typecheck\";\nimport * as utils from \"./MusicTranslator.utils\";\n\nclass MusicTranslator {\n    constructor() {\n        // default unit is quarter notes.\n        this._unit = 4;\n\n        // default is 4 units in a minute.\n        this._units_per_minute = 4;\n\n        this._translation = [];\n        this._errors = [];\n    }\n\n\n    setBaseUnit(unit_note) {\n        types.typecheckNumber(unit_note);\n\n        if(! utils.verifyUnit(unit_note)) {\n            throw new Error(\"base unit was not a valid unit. Valid units are \" +\n                                \"'1', '2', '4', '8', '16'\");\n        }\n\n        this._unit = unit_note;\n    }\n\n    getBaseUnit() {\n        return this._unit;\n    }\n\n    setUnitsPerMinute(upm) {\n        types.typecheckNumber(upm);\n        if(upm < 1) {\n            throw new Error(\"units per minute should be at least 1\");\n        }\n\n        this._units_per_minute = upm;\n    }\n\n    getUnitsPerMinute() {\n        return this._units_per_minute;\n    }\n\n    hasErrors() {\n        return this._errors.length > 0;\n    }\n\n    getErrors() {\n        return this._errors;\n    }\n\n    getErrorSummary() {\n        let error_message = \"The translator found the following errors:\\n\\n\";\n        for(let i = 0; i < this._errors.length; i++) {\n            error_message = `${error_message}Token '${this._errors[i][0]}' at position ${this._errors[i][1]} could not be translated\\n`;\n        }\n\n        return error_message;\n    }\n\n    getTranslation() {\n        return this._translation;\n    }\n\n    // This function only takes output from the MusicLexer.\n    // It translates certain tokens to\n    // the appropriate form for Tone.js to consume.\n    // If translation fails, it will report the error.\n    translate(voices_array) {\n        // NOTE. The first array in voices_array will be ignored!\n        // So each voices_array must have a length of 2 or greater to be\n        // translatable.\n        if(voices_array.length < 2) {\n            throw new Error(\"voices array does not contain any voices!\");\n        }\n\n        this._clearOldTranslation();\n\n        for(let i = 1; i < voices_array.length; i++) {\n            this._doTranslate(voices_array[i]);\n        }\n\n        return this.getTranslation();\n    }\n\n    _clearOldTranslation() {\n        this._translation = [];\n        this._errors = [];\n    }\n\n    _doTranslate(voice_array) {\n        const initial_translation = utils.translate(voice_array, this.getBaseUnit(), this.getUnitsPerMinute());\n        const errors = initial_translation[2];\n        if(errors.length > 0) {\n            // Add errors, but proceed with the translation.\n            this._addError(errors);\n        }\n        this._translation.push([initial_translation[0], initial_translation[1]]);\n    }\n\n    _addError(errors_array) {\n        // Errors array will be of the form\n        // [ [err1, pos1], [err2, pos2], [err3, pos3]]\n        this._errors = this._errors.concat(errors_array);\n    }\n}\n\nexport default MusicTranslator;","\n\nimport * as utils from \"./MusicLexer.utils\";\n\nclass TokenToNoteConverter {\n    constructor() {\n        this._note_table = new Map([\n            [\"A\", \"A4\"],\n            [\"B\", \"B4\"],\n            [\"C\", \"C4\"],\n            [\"D\", \"D4\"],\n            [\"E\", \"E4\"],\n            [\"F\", \"F4\"],\n            [\"G\", \"G4\"],\n        ]);\n\n        this._attr_table = new Map([\n            \n        ]);\n    }\n\n    convert(token, tokenPosition) {\n        utils.typecheckString(token);\n        if(typeof(tokenPosition) !== 'number') {\n            throw new Error('tokenPosition is not a number');\n        }\n\n        let complete_note_pattern = /^[A-G][1-9]$/;\n        let shorthand_note_pattern = /^[A-G]$/;\n        let attr_pattern = /^(~|!)$/;\n\n        if(shorthand_note_pattern.test(token)) {\n            return this._getNote(token);\n        }\n\n        if(complete_note_pattern.test(token)) {\n            return token;\n        }\n\n        if(attr_pattern.test(token)) {\n            // TODO What token to return? HOw to pair the tokens?\n\n            // This should go with the last non_atr token. But I can't know that yet!\n            return token;\n        }\n\n        throw new Error(\"Conversion failed! Unexpected token!\");\n\n    }\n\n    // Assumes the token is in the table.\n    _getNote(token) {\n        utils.typecheckString(token);\n        return this._note_table.get(token);\n    }\n}\n\n\nexport default TokenToNoteConverter;","\nlet Tokens = {\n    NEW_VOICE: \"NEW\",\n}\n\n\n\n\n\nexport default Tokens;","\n\nimport Tokens from \"./tokens\";\nimport * as utils from \"./MusicLexer.utils.js\";\nimport TokenToNoteConverter from \"./TokenConverter\";\n\n\nclass MusicLexer {\n    constructor() {\n        this._num_voices = 1;\n        this._voices = [[], []];\n        this._token_stream = [];\n        this._token_index = 0;\n        this._errors = [];\n        this._unit_note = \"4\";\n    }\n\n    setUnitNote(unit) {\n        typecheckString(unit);\n        if(!utils.verifyUnit(unit)) {\n            throw new Error(\"invalid unit note\");\n        }\n\n        this._unit_note = unit;\n    }\n\n    getUnitNote() {\n        return this._unit_note;\n    }\n\n    getVoice(index) {\n        if(typeof(index) !== \"number\") {\n            throw new Error(\"index not a number\");\n        }\n\n        if(index < 1) {\n            throw new Error(\"not a valid index. Valid indexes are integers >= 1\");\n        }\n\n        return this._voices[index];\n    }\n\n    getNumVoices() {\n        return this._num_voices;\n    }\n\n    getAllVoices() {\n        return this._voices;\n    }\n\n    getErrors() {\n        return this._errors;\n    }\n\n    hasErrors() {\n        return this._errors.length > 0;\n    }\n\n    getErrorSummary() {\n        let error_message = \"The following errors were found:\\n\\n\";\n        for(let i = 0; i < this._errors.length; i++) {\n            error_message = `${error_message}${this._errors[i][0]} at token position ${this._errors[i][1]}\\n`;\n        }\n        return error_message;\n    }\n\n    lex(music) {\n        utils.typecheckString(music);\n\n        this._clearOldMusic();\n        this._doLexing(music);\n\n        return this.getAllVoices();\n    }\n\n    _clearOldMusic() {\n        // reset token stream\n        this._token_stream = [];\n        this._token_index = 0;\n\n        // Set voices to start at index 1. Index 0 is never used.\n        this._voices = [[], []];\n        this._num_voices = 1;\n\n        // Reset all previously detected errors.\n        this._errors = [];\n    }\n\n    _doLexing(music) {\n        utils.typecheckString(music);\n\n        this._preprocessMusic(music);\n        this._process();\n    }\n\n    _preprocessMusic(music) {\n        utils.typecheckString(music);\n\n        // Split on whitespace only into an array.\n        this._token_stream = utils.preprocess(music);\n    }\n\n    _process() {\n        while(this._hasMoreMusicTokens()) {\n            const token = this._nextMusicToken();\n            const curr_token_index = this._token_index - 1;\n            if(token === Tokens.NEW_VOICE) {\n                this._addNewVoice();\n            } else {\n                this._addOrRejectToken(token, curr_token_index);\n            }\n        }\n    }\n\n    _hasMoreMusicTokens() {\n        return this._token_index < this._token_stream.length;\n    }\n\n    _nextMusicToken() {\n        let token = this._token_stream[this._token_index];\n        this._token_index += 1;\n\n        return token;\n    }\n\n    _addNewVoice() {\n        this._num_voices += 1;\n        this._voices.push([]);\n    }\n\n    _addOrRejectToken(token, curr_token_index) {\n        utils.typecheckString(token);\n        utils.typecheckNumber(curr_token_index);\n\n        if(this._tokenIsInLanguage(token)) {\n            this._addNote(this._convertTokenToNote(token, curr_token_index));\n        } else {\n            // Token is not in language. so it is an error. Report it!\n            this._addError(token);\n        }\n    }\n\n    _tokenIsInLanguage(token) {\n        utils.typecheckString(token);\n\n        return utils.verifyToken(token);\n    }\n\n    _convertTokenToNote(token, token_position) {\n        utils.typecheckString(token);\n        utils.typecheckNumber(token_position);\n\n        let converter = new TokenToNoteConverter();\n\n        return converter.convert(token, token_position);\n    }\n\n    _addNote(note) {\n        utils.typecheckString(note);\n\n        this._voices[this.getNumVoices()].push(note);\n    }\n\n    _addError(token) {\n        utils.typecheckString(token);\n\n        const token_index = this._token_index - 1;\n        this._errors.push([token, token_index]);\n    }\n}\n\n\nexport default MusicLexer;","\nimport * as types from \"../utils/typecheck\";\n/*\n    This function extracts header values from a header string.\n    Headers are expected to take the following form.\n    \"<TITLE> \\n\" +\n    \"<AUTHOR> \\n\" + \n    \"unit <UNIT> upm <UPM> beat <BEAT>\"\n\n    minimal error checking is done. No time.\n*/\nexport function extractHeader(header) {\n    types.typecheckString(header);\n    let extracted = {};\n    const header_lines = header.trim().split(\"\\n\");\n    if(header_lines.length !== 3) {\n        throw new Error(\"header does not have 3 lines. Headers are expected to take the following form:\\n\"\n            + \"<TITLE> \\n\" +\n            \"<AUTHOR> \\n\" + \n            \"unit <UNIT> upm <UPM> beat <BEAT>\"\n        );\n    }\n    extracted.title = header_lines[0].trim();\n    extracted.author = header_lines[1].trim();\n    \n    const modifiers = header_lines[2].trim().split(/[\\s]+/);\n    if(modifiers.length !== 6) {\n        throw new Error(\"header modifiers were not correctly written. Should be of form 'unit <UNIT> upm <UPM> beat <BEAT>\");\n    } \n\n    let i = 0;\n    while(i < modifiers.length) {\n        if(modifiers[i] === \"unit\") {\n            extracted.unit = parseInt(modifiers[i + 1]);\n        } else if (modifiers[i] === \"upm\") {\n            extracted.upm = parseInt(modifiers[i + 1]);\n        } else if (modifiers[i] === \"beat\") {\n            extracted.beat = parseInt(modifiers[i + 1]);\n        } else {\n            throw new Error(\n                `header modifier token ${modifiers[i]} is invalid. Choose from 'unit', 'upm', and 'beat'`\n            );\n        }\n\n        i += 2;\n    }\n\n    return extracted;\n}","\nimport * as types from \"../utils/typecheck\";\nimport * as utils from \"./MusicGenerator.utils\";\n\n\nconst SCORE_START = \"-ScoreStart-\";\n\n\n// The purpose of this class is to convert \n// strings (likely read from files) that Tone.js\n// can use to play music.\nclass MusicGenerator {\n\n    constructor(lexer, translator) {\n        if(!lexer) {\n            throw new Error(\"Must provide a lexer\");\n        }\n\n        if(!translator) {\n            throw new Error(\"Must provide a translator\");\n        }\n\n        this._lexer = lexer;\n        this._translator = translator;\n        this._author = \"\";\n        this._title = \"\";\n        this._beat = 4;\n        this._unit = 4;\n    }\n\n    hasLexerErrors() {\n        return this._lexer.hasErrors();\n    }\n\n    hasTranslatorErrors() {\n        return this._translator.hasErrors();\n    }\n\n    hasErrors() {\n        return this.hasLexerErrors() || this.hasTranslatorErrors();\n    }\n\n    getErrors() {\n        return this._lexer.getErrors().concat(this._translator.getErrors());\n    }\n\n    getErrorSummary() {\n        return this._lexer.getErrorSummary() + this._translator.getErrorSummary();\n    }\n\n    getGeneratedMusic() {\n        return this._translator.getTranslation();\n    }\n\n    getTitle() {\n        return this._title;\n    }\n\n    getAuthor() {\n        return this._author;\n    }\n\n    hasUnit(unit) {\n        return unit === this._unit;\n    }\n\n    hasBeat(beat) {\n        return beat === this._beat;\n    }\n\n    hasUnitsPerMinute(upm) {\n        return upm === this._translator.getUnitsPerMinute();\n    }\n\n    getBpm() {\n        let beats_per_unit = this._beat / this._unit;\n        let bpm = beats_per_unit * this._translator.getUnitsPerMinute();\n        return bpm;\n    }\n\n    generate(music_file_string) {\n        types.typecheckString(music_file_string);\n\n        this._clearOldGeneratedMusic();\n\n        this._setHeaderValues(this._extractHeaderValues(music_file_string) );\n        \n        this._lex(this._extractScoreValues(music_file_string));\n        this._translate();\n        \n        return this.getGeneratedMusic();\n    }\n\n    _clearOldGeneratedMusic() {\n        // No state needs to be cleared.\n    }\n\n    _setHeaderValues(header) {\n        this._title = header.title ? header.title : \"Unknown\";\n        this._author = header.author ? header.author : \"Unknown\";\n        this._translator.setUnitsPerMinute(header.upm ? header.upm : 60);\n        this._unit = header.unit ? header.unit : 4;\n        this._beat = header.beat ? header.beat : 4;\n    }\n\n    _extractHeaderValues(music_file_string) {\n        types.typecheckString(music_file_string);\n        if(!music_file_string.includes(SCORE_START)) {\n            throw new Error(\"music file requires a string '-ScoreStart-' to denote the end of the header\");\n        }\n        const header = utils.extractHeader(music_file_string.split(SCORE_START)[0]);\n\n        return header;\n    }\n\n    _extractScoreValues(music_file_string) {\n        types.typecheckString(music_file_string);\n        if(!music_file_string.includes(SCORE_START)) {\n            throw new Error(`music file requires a string '${SCORE_START}' to denote the start of the score`);\n        }\n        const score = music_file_string.split(SCORE_START)[1];\n        return score;\n    }\n\n    _lex(score) {\n        types.typecheckString(score);\n        this._lexer.lex(score);\n    }\n\n    _translate() {\n        this._translator.translate(this._lexer.getAllVoices());\n    }\n\n}\n\n\nexport default MusicGenerator;\n","import Player from \"./player/Player\";\n\nimport MusicGenerator from \"./generator/MusicGenerator\";\nimport MusicLexer from \"./lexer/MusicLexer\";\nimport MusicTranslator from \"./translator/MusicTranslator\";\n\nwindow.onload = function(event) {\n\n    console.log(\"I am running\");\n    \n    let generator = new MusicGenerator(new MusicLexer(), new MusicTranslator());\n    generator.generate(\"Twinkle Twinkle Little Star\\nUnknown\\nunit 4 upm 80 beat 4\\n\" + \n                         \"\\n-ScoreStart- \" +\n                         \"C C G G A A G ~ F F E E D D C ~ NEW \\n\" +\n                         \"C5 C5 G5 G5 A5 A5 G5 ~ F5 F5 E5 E5 D5 D5 C5 ~ NEW\\n\" +\n                         \"E E B B C5 C5 B ~ A A G G F F E ~\"\n    );\n    console.log(generator.getGeneratedMusic());\n    if(generator.hasErrors()) {\n        console.log(\"UNEXPECTED ERROR\");\n        return;\n    }\n\n    let player = new Player();\n    player.schedule(\n        generator.getGeneratedMusic()\n        /*[[\n            [\"C4\", \"D4\", \"E4\", \"F4\", \"G4\", \"A4\", \"B4\", \"C5\"],\n            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n        ]],*/\n        /*[[]\n            [\"E4\", \"F4\", \"G4\", \"A4\", \"B4\", \"C5\", \"D5\", \"E5\"],\n            [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n        ]]*/\n    );\n    const playBtn = document.getElementById(\"play\");\n    const stopBtn = document.getElementById(\"stop\");\n    playBtn.addEventListener(\"click\", (event) => {\n        player.play();\n        playBtn.disabled = true;\n        stopBtn.disabled = false;\n    });\n    stopBtn.addEventListener(\"click\", (event) => {\n        player.stop();\n        playBtn.disabled = false;\n        stopBtn.disabled = true;\n    })\n}"],"sourceRoot":""}