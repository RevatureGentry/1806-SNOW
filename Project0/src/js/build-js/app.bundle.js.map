{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/js/typecheck.js","webpack:///./src/js/MusicLexer.utils.js","webpack:///./src/js/MusicTranslator.utils.js","webpack:///./src/js/MusicTranslator.js","webpack:///./src/js/TokenConverter.js","webpack:///./src/js/tokens.js","webpack:///./src/js/MusicLexer.js","webpack:///./src/js/MusicGenerator.utils.js","webpack:///./src/js/MusicGenerator.js","webpack:///./src/js/Player.js","webpack:///./src/js/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","typecheckString","input","Error","typecheckNumber","typecheckBool","preprocess","trimmed","trim","split","verifyToken","token","test","verifyUnit","unit","types","translate","voice_array","units_per_minute","voice_index","duration_count","result","notes","durations","errors","length","push","convertCountToDuration","minute_fraction","Math","floor","utils","MusicTranslator","_classCallCheck","this","_unit","_units_per_minute","_translation","_errors","unit_note","upm","error_message","voices_array","_clearOldTranslation","_doTranslate","getTranslation","initial_translation","getBaseUnit","getUnitsPerMinute","_addError","errors_array","concat","TokenToNoteConverter","_note_table","Map","_attr_table","tokenPosition","_getNote","NEW_VOICE","MusicLexer","_num_voices","_voices","_token_stream","_token_index","_unit_note","index","music","_clearOldMusic","_doLexing","getAllVoices","_preprocessMusic","_process","_hasMoreMusicTokens","_nextMusicToken","curr_token_index","Tokens","_addNewVoice","_addToken","_tokenIsInLanguage","addNote","convertTokenToNote","token_position","convert","note","getNumVoices","token_index","extractHeader","header","extracted","header_lines","title","author","modifiers","parseInt","beat","MusicGenerator","lexer","translator","_lexer","_translator","_author","_title","_beat","hasErrors","hasLexerErrors","hasTranslatorErrors","getErrors","getErrorSummary","music_file_string","_clearOldGeneratedMusic","_setHeaderValues","_extractHeaderValues","_lex","_extractScoreValues","_translate","getGeneratedMusic","setUnitsPerMinute","includes","score","lex","Player","_instruments","Tone","Synth","oscillator","type","harmonicity","modulationType","envelope","attackCurve","attack","decay","sustain","release","portamento","toMaster","overall_time","notes_array","dur_array","noteIndex","Transport","schedule","_scheduleNote","cancel","duration","instrument","time","triggerAttackRelease","start","pause","stop","generator","player","existsUserChosenFile","console","log","document","getElementById","files","window","onload","event","preview","addEventListener","reader","FileReader","target","generate","play","readAsText","playUserChosenFile","selected","LAYLA","playUserSelectedMusic","playUserChosenMusic","disabled","addPreviewEvents","addStartEvents"],"mappings":"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","file":"app.bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 11);\n","export function typecheckString(input) {\n    if(typeof(input) !== 'string') {\n        throw new Error(\"input is not a string\");\n    }\n}\n\nexport function typecheckNumber(input) {\n    if(typeof(input) !== 'number') {\n        throw new Error(\"input is not a number\");\n    }\n}\n\nexport function typecheckBool(input) {\n    if(typeof(input) !== 'boolean') {\n        throw new Error(\"input is not a boolean\");\n    }\n}","\n\n\nexport function preprocess(input) {\n    typecheckString(input);\n\n    let trimmed = input.trim();\n    if(trimmed === \"\") {\n        return [];\n    } else {\n        return trimmed.split(/[\\s]+/);\n    }\n}\n\nexport function verifyToken(token) {\n    typecheckString(token);\n\n    // See regular expression documentation for JavaScript.\n    let noteFormat = /^([A-G][1-9]?|(!)?~)$/;\n    return noteFormat.test(token);\n}\n\nexport function typecheckString(input) {\n    if(typeof(input) !== 'string') {\n        throw new Error(\"input is not a string\");\n    }\n}\n\nexport function typecheckNumber(input) {\n    if(typeof(input) !== 'number') {\n        throw new Error(\"input is not a number\");\n    }\n}\n\nexport function verifyUnit(unit) {\n    typecheckString(unit);\n\n    //see regex documentation for JavaScript.\n    let unitFormat = /^(([1248])|16)$/;\n    return unitFormat.test(unit);\n\n}","import * as types from \"./typecheck\";\n\nexport function verifyUnit(unit) {\n    types.typecheckNumber(unit);\n\n    return  unit === 1 ||\n            unit === 2 ||\n            unit === 4 ||\n            unit === 8 ||\n            unit === 16;\n}\n\n/*\n    Returns an array of the form\n    [\n        notes_array,\n        duration_array,\n        errors_array    [OPTIONAL]\n    ]\n*/\nexport function translate(voice_array, unit, units_per_minute) {\n    types.typecheckNumber(unit);\n    types.typecheckNumber(units_per_minute);\n\n    let voice_index = 0;\n    let duration_count = 0;\n\n    const result = [];\n    const notes = [];\n    const durations = [];\n    const errors = [];\n\n    while(voice_index < voice_array.length) {\n        if(voice_array[voice_index] === \"~\") {\n            if(duration_count === 0) {\n                errors.push([voice_array[voice_index], voice_index]);\n            } else {\n                duration_count += 1;\n            }\n        } else {\n            // Then the token is a note.\n\n            // Add the note.\n            notes.push(voice_array[voice_index]);\n\n            // Add the duration of the previous note.\n            if(duration_count > 0) {\n                durations.push(convertCountToDuration(duration_count, unit, units_per_minute));\n            }\n\n            // Reset the duration.\n            duration_count = 1;\n        }\n              \n        // Increment to look at next voice token.\n        voice_index++;\n    };\n\n    // Add the last duration, since it would not have added during the loop.\n    durations.push(convertCountToDuration(duration_count, unit, units_per_minute));\n\n    // TODO: Return correct value by processing the voice_array.\n\n    result.push(notes);\n    result.push(durations);\n    result.push(errors);\n    return result;\n}\n\nexport function convertCountToDuration(duration_count, unit, units_per_minute) {\n    types.typecheckNumber(duration_count);\n    types.typecheckNumber(unit);\n    types.typecheckNumber(units_per_minute);\n\n    const minute_fraction = duration_count / units_per_minute;\n    const duration_in_seconds = Math.floor(minute_fraction * 60 * 1000) / 1000;\n\n    return duration_in_seconds;\n}","\nimport * as types from \"./typecheck\";\nimport * as utils from \"./MusicTranslator.utils\";\n\nclass MusicTranslator {\n    constructor() {\n        // default unit is quarter notes.\n        this._unit = 4;\n\n        // default is 4 units in a minute.\n        this._units_per_minute = 4;\n\n        this._translation = [];\n        this._errors = [];\n    }\n\n\n    setBaseUnit(unit_note) {\n        types.typecheckNumber(unit_note);\n\n        if(! utils.verifyUnit(unit_note)) {\n            throw new Error(\"base unit was not a valid unit. Valid units are \" +\n                                \"'1', '2', '4', '8', '16'\");\n        }\n\n        this._unit = unit_note;\n    }\n\n    getBaseUnit() {\n        return this._unit;\n    }\n\n    setUnitsPerMinute(upm) {\n        types.typecheckNumber(upm);\n        if(upm < 1) {\n            throw new Error(\"units per minute should be at least 1\");\n        }\n\n        this._units_per_minute = upm;\n    }\n\n    getUnitsPerMinute() {\n        return this._units_per_minute;\n    }\n\n    hasErrors() {\n        return this._errors.length > 0;\n    }\n\n    getErrors() {\n        return this._errors;\n    }\n\n    getErrorSummary() {\n        let error_message = \"The translator found the following errors:\\n\\n\";\n        for(let i = 0; i < this._errors.length; i++) {\n            error_message = `${error_message}Token '${this._errors[i][0]}' at position ${this._errors[i][1]} could not be translated\\n`;\n        }\n\n        return error_message;\n    }\n\n    getTranslation() {\n        return this._translation;\n    }\n\n    // This function only takes output from the MusicLexer.\n    // It translates certain tokens to\n    // the appropriate form for Tone.js to consume.\n    // If translation fails, it will report the error.\n    translate(voices_array) {\n        // NOTE. The first array in voices_array will be ignored!\n        // So each voices_array must have a length of 2 or greater to be\n        // translatable.\n        if(voices_array.length < 2) {\n            throw new Error(\"voices array does not contain any voices!\");\n        }\n\n        this._clearOldTranslation();\n\n        for(let i = 1; i < voices_array.length; i++) {\n            this._doTranslate(voices_array[i]);\n        }\n\n        return this.getTranslation();\n    }\n\n    _clearOldTranslation() {\n        this._translation = [];\n        this._errors = [];\n    }\n\n    _doTranslate(voice_array) {\n        const initial_translation = utils.translate(voice_array, this.getBaseUnit(), this.getUnitsPerMinute());\n        const errors = initial_translation[2];\n        if(errors.length > 0) {\n            // Add errors, but proceed with the translation.\n            this._addError(errors);\n        }\n        this._translation.push([initial_translation[0], initial_translation[1]]);\n    }\n\n    _addError(errors_array) {\n        // Errors array will be of the form\n        // [ [err1, pos1], [err2, pos2], [err3, pos3]]\n        this._errors = this._errors.concat(errors_array);\n    }\n}\n\nexport default MusicTranslator;","\n\nimport * as utils from \"./MusicLexer.utils\";\n\nclass TokenToNoteConverter {\n    constructor() {\n        this._note_table = new Map([\n            [\"A\", \"A4\"],\n            [\"B\", \"B4\"],\n            [\"C\", \"C4\"],\n            [\"D\", \"D4\"],\n            [\"E\", \"E4\"],\n            [\"F\", \"F4\"],\n            [\"G\", \"G4\"],\n        ]);\n\n        this._attr_table = new Map([\n            \n        ]);\n    }\n\n    convert(token, tokenPosition) {\n        utils.typecheckString(token);\n        if(typeof(tokenPosition) !== 'number') {\n            throw new Error('tokenPosition is not a number');\n        }\n\n        let complete_note_pattern = /^[A-G][1-9]$/;\n        let shorthand_note_pattern = /^[A-G]$/;\n        let attr_pattern = /^([!]?[~])$/;\n\n        if(shorthand_note_pattern.test(token)) {\n            return this._getNote(token);\n        }\n\n        if(complete_note_pattern.test(token)) {\n            return token;\n        }\n\n        if(attr_pattern.test(token)) {\n            // TODO What token to return? HOw to pair the tokens?\n\n            // This should go with the last non_atr token. But I can't know that yet!\n            return token;\n        }\n\n        throw new Error(\"Conversion failed! Unexpected token!\");\n\n    }\n\n    // Assumes the token is in the table.\n    _getNote(token) {\n        utils.typecheckString(token);\n        return this._note_table.get(token);\n    }\n}\n\n\nexport default TokenToNoteConverter;","\nlet Tokens = {\n    NEW_VOICE: \"NEW\",\n}\n\n\n\n\n\nexport default Tokens;","\n\nimport Tokens from \"./tokens\";\nimport * as utils from \"./MusicLexer.utils.js\";\nimport TokenToNoteConverter from \"./TokenConverter\";\n\n\nclass MusicLexer {\n    constructor() {\n        this._num_voices = 1;\n        this._voices = [[], []];\n        this._token_stream = [];\n        this._token_index = 0;\n        this._errors = [];\n        this._unit_note = \"4\";\n    }\n\n    setUnitNote(unit) {\n        typecheckString(unit);\n        if(!utils.verifyUnit(unit)) {\n            throw new Error(\"invalid unit note\");\n        }\n\n        this._unit_note = unit;\n    }\n\n    getUnitNote() {\n        return this._unit_note;\n    }\n\n    getVoice(index) {\n        if(typeof(index) !== \"number\") {\n            throw new Error(\"index not a number\");\n        }\n\n        if(index < 1) {\n            throw new Error(\"not a valid index. Valid indexes are integers >= 1\");\n        }\n\n        return this._voices[index];\n    }\n\n    getNumVoices() {\n        return this._num_voices;\n    }\n\n    getAllVoices() {\n        return this._voices;\n    }\n\n    getErrors() {\n        return this._errors;\n    }\n\n    hasErrors() {\n        return this._errors.length > 0;\n    }\n\n    getErrorSummary() {\n        let error_message = \"The following errors were found:\\n\\n\";\n        for(let i = 0; i < this._errors.length; i++) {\n            error_message = `${error_message}${this._errors[i][0]} at token position ${this._errors[i][1]}\\n`;\n        }\n        return error_message;\n    }\n\n    lex(music) {\n        utils.typecheckString(music);\n\n        this._clearOldMusic();\n        this._doLexing(music);\n\n        return this.getAllVoices();\n    }\n\n    _clearOldMusic() {\n        // reset token stream\n        this._token_stream = [];\n        this._token_index = 0;\n\n        // Set voices to start at index 1. Index 0 is never used.\n        this._voices = [[], []];\n        this._num_voices = 1;\n\n        // Reset all previously detected errors.\n        this._errors = [];\n    }\n\n    _doLexing(music) {\n        utils.typecheckString(music);\n\n        this._preprocessMusic(music);\n        this._process();\n    }\n\n    _preprocessMusic(music) {\n        utils.typecheckString(music);\n\n        // Split on whitespace only into an array.\n        this._token_stream = utils.preprocess(music);\n    }\n\n    _process() {\n        while(this._hasMoreMusicTokens()) {\n            const token = this._nextMusicToken();\n            const curr_token_index = this._token_index - 1;\n            if(token === Tokens.NEW_VOICE) {\n                this._addNewVoice();\n            } else {\n                this._addToken(token, curr_token_index);\n            }\n        }\n    }\n\n    _hasMoreMusicTokens() {\n        return this._token_index < this._token_stream.length;\n    }\n\n    _nextMusicToken() {\n        let token = this._token_stream[this._token_index];\n        this._token_index += 1;\n\n        return token;\n    }\n\n    _addNewVoice() {\n        this._num_voices += 1;\n        this._voices.push([]);\n    }\n\n    _addToken(token, curr_token_index) {\n        utils.typecheckString(token);\n        utils.typecheckNumber(curr_token_index);\n\n        if(this._tokenIsInLanguage(token)) {\n            this.addNote(this.convertTokenToNote(token, curr_token_index));\n        } else {\n            // Token is not in language. so it is an error. Report it!\n            this._addError(token);\n        }\n    }\n\n    _tokenIsInLanguage(token) {\n        utils.typecheckString(token);\n\n        return utils.verifyToken(token);\n    }\n\n    convertTokenToNote(token, token_position) {\n        utils.typecheckString(token);\n        utils.typecheckNumber(token_position);\n\n        let converter = new TokenToNoteConverter();\n\n        return converter.convert(token, token_position);\n    }\n\n    addNote(note) {\n        utils.typecheckString(note);\n\n        this._voices[this.getNumVoices()].push(note);\n    }\n\n    _addError(token) {\n        utils.typecheckString(token);\n\n        const token_index = this._token_index - 1;\n        this._errors.push([token, token_index]);\n    }\n}\n\n\nexport default MusicLexer;","\nimport * as types from \"./typecheck\";\n/*\n    This function extracts header values from a header string.\n    Headers are expected to take the following form.\n    \"<TITLE> \\n\" +\n    \"<AUTHOR> \\n\" + \n    \"unit <UNIT> upm <UPM> beat <BEAT>\"\n\n    minimal error checking is done. No time.\n*/\nexport function extractHeader(header) {\n    types.typecheckString(header);\n    let extracted = {};\n    const header_lines = header.trim().split(\"\\n\");\n    if(header_lines.length !== 3) {\n        throw new Error(\"header does not have 3 lines. Headers are expected to take the following form:\\n\"\n            + \"<TITLE> \\n\" +\n            \"<AUTHOR> \\n\" + \n            \"unit <UNIT> upm <UPM> beat <BEAT>\"\n        );\n    }\n    extracted.title = header_lines[0].trim();\n    extracted.author = header_lines[1].trim();\n    \n    const modifiers = header_lines[2].trim().split(/[\\s]+/);\n    if(modifiers.length !== 6) {\n        throw new Error(\"header modifiers were not correctly written. Should be of form 'unit <UNIT> upm <UPM> beat <BEAT>\");\n    } \n\n    let i = 0;\n    while(i < modifiers.length) {\n        if(modifiers[i] === \"unit\") {\n            extracted.unit = parseInt(modifiers[i + 1]);\n        } else if (modifiers[i] === \"upm\") {\n            extracted.upm = parseInt(modifiers[i + 1]);\n        } else if (modifiers[i] === \"beat\") {\n            extracted.beat = parseInt(modifiers[i + 1]);\n        } else {\n            throw new Error(\n                `header modifier token ${modifiers[i]} is invalid. Choose from 'unit', 'upm', and 'beat'`\n            );\n        }\n\n        i += 2;\n    }\n\n    return extracted;\n}","\nimport * as types from \"./typecheck\";\nimport * as utils from \"./MusicGenerator.utils\";\n\n\nconst SCORE_START = \"-ScoreStart-\";\n\n\n// The purpose of this class is to convert \n// strings (likely read from files) that Tone.js\n// can use to play music.\nclass MusicGenerator {\n\n    constructor(lexer, translator) {\n        if(!lexer) {\n            throw new Error(\"Must provide a lexer\");\n        }\n\n        if(!translator) {\n            throw new Error(\"Must provide a translator\");\n        }\n\n        this._lexer = lexer;\n        this._translator = translator;\n        this._author = \"\";\n        this._title = \"\";\n        this._beat = 4;\n        this._unit = 4;\n    }\n\n    hasLexerErrors() {\n        return this._lexer.hasErrors();\n    }\n\n    hasTranslatorErrors() {\n        return this._translator.hasErrors();\n    }\n\n    hasErrors() {\n        return this.hasLexerErrors() || this.hasTranslatorErrors();\n    }\n\n    getErrors() {\n        return this._lexer.getErrors().concat(this._translator.getErrors());\n    }\n\n    getErrorSummary() {\n        return this._lexer.getErrorSummary() + this._translator.getErrorSummary();\n    }\n\n    getGeneratedMusic() {\n        return this._translator.getTranslation();\n    }\n\n    getTitle() {\n        return this._title;\n    }\n\n    getAuthor() {\n        return this._author;\n    }\n\n    hasUnit(unit) {\n        return unit === this._unit;\n    }\n\n    hasBeat(beat) {\n        return beat === this._beat;\n    }\n\n    hasUnitsPerMinute(upm) {\n        return upm === this._translator.getUnitsPerMinute();\n    }\n\n    getBpm() {\n        let beats_per_unit = this._beat / this._unit;\n        let bpm = beats_per_unit * this._translator.getUnitsPerMinute();\n        return bpm;\n    }\n\n    generate(music_file_string) {\n        types.typecheckString(music_file_string);\n\n        this._clearOldGeneratedMusic();\n\n        this._setHeaderValues(this._extractHeaderValues(music_file_string) );\n        \n        this._lex(this._extractScoreValues(music_file_string));\n        this._translate();\n        \n        return this.getGeneratedMusic();\n    }\n\n    _clearOldGeneratedMusic() {\n        // No state needs to be cleared.\n    }\n\n    _setHeaderValues(header) {\n        this._title = header.title ? header.title : \"Unknown\";\n        this._author = header.author ? header.author : \"Unknown\";\n        this._translator.setUnitsPerMinute(header.upm ? header.upm : 60);\n        this._unit = header.unit ? header.unit : 4;\n        this._beat = header.beat ? header.beat : 4;\n    }\n\n    _extractHeaderValues(music_file_string) {\n        types.typecheckString(music_file_string);\n        if(!music_file_string.includes(SCORE_START)) {\n            throw new Error(\"music file requires a string '-ScoreStart-' to denote the end of the header\");\n        }\n        const header = utils.extractHeader(music_file_string.split(SCORE_START)[0]);\n\n        return header;\n    }\n\n    _extractScoreValues(music_file_string) {\n        types.typecheckString(music_file_string);\n        if(!music_file_string.includes(SCORE_START)) {\n            throw new Error(`music file requires a string '${SCORE_START}' to denote the start of the score`);\n        }\n        const score = music_file_string.split(SCORE_START)[1];\n        return score;\n    }\n\n    _lex(score) {\n        types.typecheckString(score);\n        this._lexer.lex(score);\n    }\n\n    _translate() {\n        this._translator.translate(this._lexer.getAllVoices());\n    }\n\n}\n\n\nexport default MusicGenerator;\n","\nimport * as types from \"./typecheck\";\n\n// This class is reponsible for taking a lexed and translated\n// *.music file and playing it in the browser. Therefore it will utilize Tone.js\n\nclass Player {\n    constructor() {\n        this._instruments = [];\n        //this._instrument = new Tone.Synth().toMaster();\n        //this._instrument_2 = new Tone.Synth().toMaster();\n    }\n\n    /*\n        example notes:\n        [  // array of voices.\n            [   // each voice is an array of notes and durations to play them.\n                [\"A4\", \"B4\"],\n                [1, 2], // The intention is to play notes in sequence.\n            ],\n            [\n                [\"C4\", \"D4\"],\n                [3, 5],\n\n                // Note that voices do not play at identical times. \"D4\" will start\n                // when \"B4\" ends. That is how the scheduling works.\n            ]\n        ]\n    */\n    schedule(notes) {\n        this._clearOldMusic();\n\n        for(let i = 0; i < notes.length; i++) {\n            if(notes[i][0].length !== notes[i][1].length) {\n                throw new Error(\"number of notes does not equal number of durations\");\n            }\n            // add an instrument for each voice.\n            this._instruments.push(new Tone.Synth({\n                \"oscillator\" : {\n                    \"type\" : \"amtriangle\",\n                    \"harmonicity\" : 0.5,\n                    \"modulationType\" : \"sine\"\n                },\n                \"envelope\" : {\n                    \"attackCurve\" : 'exponential',\n                    \"attack\" : 0.05,\n                    \"decay\" : 0.2,\n                    \"sustain\" : 0.2,\n                    \"release\" : 1.5,\n                },\n                \"portamento\" : 0.05\n            }).toMaster());\n\n            //for each note-duration pair, schedule the note with correct duration.\n            let overall_time = 0;\n            let notes_array = notes[i][0];\n            let dur_array = notes[i][1];\n            for(let noteIndex = 0; noteIndex < notes_array.length; noteIndex++) {\n                Tone.Transport.schedule(\n                    this._scheduleNote(notes_array[noteIndex], dur_array[noteIndex]),\n                    overall_time\n                );\n\n                // Increment the overall_time for the scheduling of the next note.\n                overall_time += dur_array[noteIndex];\n            }\n        }\n    }\n\n    _clearOldMusic() {\n        Tone.Transport.cancel();\n    }\n\n    _scheduleNote(note, duration) {\n        types.typecheckString(note);\n        types.typecheckNumber(duration);\n\n        let instrument = this._instruments[this._instruments.length - 1];\n        return function playNote(time) {\n            instrument.triggerAttackRelease(note, duration, time);\n        }\n    }\n\n    play() {\n        Tone.Transport.start('+0.1');\n\n        /*\n        let instrument = this._instrument;\n        let instrument_2 = this._instrument_2;\n        return function doPlay(time) {\n            instrument_2.triggerAttackRelease(\"G4\", \"3\", time);\n            instrument.triggerAttackRelease(\"C4\", \"3\", time);\n        }*/\n    }\n\n    pause() {\n        Tone.Transport.pause();\n    }\n\n    stop() {\n        Tone.Transport.stop();\n    }\n}\n\nexport default Player;\n","import Player from \"./Player\";\nimport MusicGenerator from \"./MusicGenerator\";\nimport MusicLexer from \"./MusicLexer\";\nimport MusicTranslator from \"./MusicTranslator\";\n\n(function main() {\n    const generator = new MusicGenerator(new MusicLexer(), new MusicTranslator());\n    const player = new Player();\n\n    window.onload = function initUserInteractions(event) {\n        console.log(\"Script running at load\");\n        /*generator.generate(LAYLA);\n        player.schedule(generator.getGeneratedMusic());\n        player.play();*/\n\n        addPreviewEvents();\n        addStartEvents();\n    };\n\n\n    function addPreviewEvents() {\n        const preview = document.getElementById(\"start-preview\");\n        const stop = document.getElementById(\"stop-preview\");\n\n        preview.addEventListener('click', function startPreview(event) {\n            playUserChosenMusic();\n\n            preview.disabled = true;\n            stop.disabled = false;\n        });\n\n        stop.addEventListener('click', function stopPreview(event) {\n            player.stop();\n\n            preview.disabled = false;\n            stop.disabled = true;\n        });\n\n        function playUserChosenMusic() {\n            if(existsUserChosenFile()) {\n                playUserChosenFile();\n            } else {\n                playUserSelectedMusic();\n            }\n    \n            function playUserChosenFile() {\n                let reader = new FileReader();\n                reader.onload = function returnFileAsString(event) {\n                    // When the file has been read, start playing it.\n                    console.log(event.target.result);\n                    generator.generate(event.target.result);\n                    player.schedule(generator.getGeneratedMusic());\n                    player.play();\n                };\n                reader.readAsText(document.getElementById(\"user-music\").files[0]);\n            }\n    \n            function playUserSelectedMusic() {\n                const selected = document.getElementById(\"provided-music\");\n                let music;\n                if(selected === \"layla\") {\n                    music = LAYLA;\n                } else if (selected === \"duck\") {\n                    music = LAYLA;\n                } else if (selected === \"user\") {\n                    music = LAYLA;\n                } else {\n                    throw new Error(\"An invalid selection was made!\");\n                }\n                generator.generate(music);\n                player.schedule(generator.getGeneratedMusic());\n                player.play();\n            }\n        }\n    }\n\n    function addStartEvents() {\n        const start = document.getElementById(\"start-game\");\n        const pause = document.getElementById(\"pause-game\");\n\n        start.addEventListener('click', function startGame(event) {\n            start.disabled = true;\n            pause.disabled = false;\n        });\n\n        pause.addEventListener('click', function pauseGame(event) {\n            start.disabled = false;\n            pause.disabled = true;\n        });\n\n        if(existsUserChosenFile()) {\n            playGameWithChosenFile();\n        } else {\n            playGameWithSelectionMusic();\n        }\n\n        function playGameWithChosenFile() {\n        }\n\n        function playGameWithSelectionMusic() {\n            \n        }\n    }\n\n\n    function existsUserChosenFile() {\n        console.log(\"A file is selected!\");\n        return document.getElementById(\"user-music\").files.length > 0;\n    }\n\n\n    var LAYLA = \n        \"Layla \\n\" +\n        \"Eric Clapton \\n\" +\n        \"unit 16 upm 240 beat 4 \\n \" +\n        \"-ScoreStart- \\n\" +\n        \"A5 C6 D6 E6 D6 A5 C6 ~ ~ ~ E5 E5 E5 ~ D5 D5 C5 D5 E5\";\n})();"],"sourceRoot":""}