-- More Chinook Examples: 

-- Write a SQL Query that contains the names of all tracks that are longer than 6 minutes
select track.name from track where milliseconds > 360000;

-- Write a SQL Query to find the biggest song (which takes up the most space)
select MAX(milliseconds) as LongestTrack from track;

-- Write a SQL Query that contains the titles of all albums with tracks longer than 6 minutes in them 
select a.title from track t
    inner join album a
    on t.albumid = a.albumid
    where milliseconds > 360000
    group by a.title;

-- Write a SQL Query that contains the albumId and number of songs in the album 
select a.albumid, count(t.albumId) from track t  
    inner join album a
    on t.albumid  = a.albumid
    group by a.ALBUMID
    order by a.ALBUMID;

--Write a SQL query that contains artist's names and the number of tracks they have produced 
--(assume an artist produced a track if it appears in one of their albums)

select ar.name, ar.artistid, count(*) from artist ar
    inner join album a
    on ar.artistid = a.artistid
    inner join track t 
    on a.albumid = t.albumid
    group by ar.artistid, ar.name
    order by ar.artistid;

-- Write a SQL Query that returns the most purchased media type
-- Chain of Command: 
--      Mediatype (mediatypeid)-> Track (trackid)-> Invoiceline
-- Answer: Should return Mediatype.name = MPEG audio file, Quantity = 1938

-- Query Version 1: Returns the definitive answer, just without the Mediatype.name for context.
select max(purchasecount) from(
    select mt.name MediaName, SUM(il.QUANTITY) purchasecount from mediatype mt
        inner join track t
        on t.mediatypeid = mt.mediatypeid
        inner join invoiceline il
        on il.trackid = t.trackid
        where mt.mediatypeid = t.mediatypeid
        group by mt.name);

-- Query Version 2: Returns the whole table of counts and MediaNames (is easier to understand contextually, but doesn't give the flat answer). 
select MediaName, max(purchasecount) from(
    select mt.name MediaName, SUM(il.QUANTITY) purchasecount from mediatype mt
        inner join track t
        on t.mediatypeid = mt.mediatypeid
        inner join invoiceline il
        on il.trackid = t.trackid
        where mt.mediatypeid = t.mediatypeid
        group by mt.name)
        group by MediaName;
        
-- Query Version 3: Get the proper format with select * () where rownum <=1.
select * from(
    select mt.name MediaName, SUM(il.QUANTITY) purchasecount from mediatype mt
        inner join track t
        on t.mediatypeid = mt.mediatypeid
        inner join invoiceline il
        on il.trackid = t.trackid
        where mt.mediatypeid = t.mediatypeid
        group by mt.name
        order by sum(il.quantity) DESC
        ) where rownum <=1;
        
--Write a SQL Query showing customers not in the US
-- One Table, Customer
select * from customer c where c.country != 'USA';
-- Can also extend this with OR for different versions of the same name, if feeling sketchy about inconsistent inputs. 

--Write a SQL Query showing a unique list of billing countries on the Invoice table
select distinct i.billingcountry from invoice i order by i.BILLINGCOUNTRY ASC;

--Write a SQL Query that shows the Invoice Total, Customer Name, Country, and Sales agent for all invoices and customers 
-- Write a query that returns all of the above columns in both tables, including details from the employee table.
    -- Invoice values: Total, BillingCountry
        -- Relavent Invoice Keys: CustomerID
    -- Customer Values: FirstName + LastName, Country
        -- Relavent Customer Keys: CustomerID, SupportRepId == Employee.EmployeeId
    -- Employee Values: Title = "Sales Support Agent", FirstName + LastName
        -- Relavent Employee Keys: EmployeeId == Customer.SupportRepId
--The above was left in to show my thought process.
        
select c.firstname || ' ' || c.lastname CustomerName, c.country Country, 
    i.total InvoiceTotal, e.firstname || ' ' || e.lastname SalesAgentName from invoice i
    inner join customer c
    on i.customerid = c.customerid
    inner join employee e
    on c.supportrepid = e.employeeid
    order by CustomerName ASC;

--Write a SQL Query that shows all Tracks, but displays no IDs. Should also include the Album name, Media Type, and Genre.
--  Restated: Write a query that Shows all Tracks with Album Name, Media Type, and Genre, but without including the Track ID. 
select t.name TrackName, a.title AlbumTitle, mt.name MediaTypeName, g.name GenreName from track t
    inner join album a
    on t.albumid = a.albumid
    inner join mediatype mt
    on t.mediatypeid = mt.mediatypeid
    inner join genre g
    on t.genreid = g.genreid;

--Write a SQL Query that returns the Top 40 Songs for 2013
-- Restated: Return the top 40 songs in the year 2013. Use the rownum clause to limit how many rows are returned.
select * from (     
    select t.name SongName, sum(il.quantity) Downloads from track t
        inner join invoiceline il
        on t.trackid = il.trackid
        inner join invoice i
        on il.invoiceid = i.invoiceid
        where i.invoicedate >= DATE '2013-01-01'
        group by t.name
        order by Downloads DESC
    ) where rownum <= 40; --Personal note: you have to wrap an entire statement like this when you want to limit the sorted values.

-- Write a SQL Query that shows which sales agent made the most in sales overall
--  Restated: Write a query that returns the single sales agent with the maximum sales. 
    -- Relavent tables/columns: 
        --Employee: firstname+lastname, Title (For sorting), (Key) employeeid
        --Customer: (Key) supportrepid, (Key) customerid
        --Invoice: total, (Key) customerid
    
select * from(select e.lastname || ', ' || e.firstname SalesRep, sum(i.total) TotalSales from employee e
    inner join customer c
    on c.supportrepid = e.employeeid
    inner join invoice i
    on i.customerid = c.customerid
    where e.title = 'Sales Support Agent'
    group by e.lastname || ', ' || e.firstname
    order by sum(i.total) DESC
    ) where rownum <= 1;

-- Write a SQL Query that shows the top 3 best selling artists 
--  Restated: Find the 3 best selling artists.
    -- Relavent Tables/Columns:
        -- Artist: (key) artistid
        -- Album: (key) albumid, (key) artistid 
        -- Track: (key) trackid, (key) albumid
        -- InvoiceLine: (key) invoiceid, (key) trackid
        -- Invoice: invoice.total, (key) invoiceid
select * from (
    select ar.name, sum(i.total) from artist ar
        inner join album al
        on ar.artistid = al.artistid
        inner join track t
        on t.albumid = al.albumid
        inner join invoiceline il
        on il.trackid = t.trackid
        inner join invoice i
        on i.invoiceid = il.invoiceid
        group by ar.NAME
        order by sum(i.total) DESC
    ) where rownum <= 3;
    
-- Write a SQL Query that returns which albums have no Heavy Metal tracks
--  Restated: Return all albums where no tracks have genre.name = 'Heavy Metal'. 
select a.title from album a 
    inner join track t
    on t.albumid = a.albumid
    inner join genre g
    on g.genreid = t.genreid
    where g.name != 'Heavy Metal'
    group by a.title
    order by a.title ASC;

-- Write a SQL Query to find the the managers of employees supporting Brazilian customers.
--  Restated: Return the managers of each employee that has a Brazilian customer. 
    -- Relavent Tables/Columns: 
        -- Employee: firstname + lastname, (key) EmployeeId, (key) ReportsTo
        -- Customer: country, (key) supportrepid
    -- Solution: First, self join to find all managers. Then, go down the Chain to find all customers that are from Brazil. 
select e2.firstname || ' ' || e2.lastname ManagerName from employee e1
    join employee e2 
    on e1.reportsto = e2.employeeid
    inner join customer c
    on c.supportrepid = e1.employeeid
    where c.country = 'Brazil'
    group by e2.firstname || ' ' || e2.lastname;


